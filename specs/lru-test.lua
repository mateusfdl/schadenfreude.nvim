local LRU = require("../lua/lru")

describe("LRU Cache", function()
	describe("on insert", function()
		it("creates a new LRU cache with the given max tokens", function()
			local cache = LRU.new(100)
			assert.equals(cache.max_tokens, 100)
			assert.equals(cache.current_tokens, 0)
			assert.equals(cache.head, nil)
			assert.equals(cache.tail, nil)
		end)

		it("adds a new item", function()
			local cache = LRU.new(100)
			cache:put("key1", "value1", 10)
			assert.equals(cache.cache["key1"].node.tokens, "value1")
			assert.equals(cache.cache["key1"].content, "value1")
			assert.equals(cache.cache["key1"].count_tokens, 10)
			assert.equals(cache.head.tokens, "value1")
			assert.equals(cache.tail.tokens, "value1")
			assert.equals(cache.current_tokens, 10)
		end)

		it("adds multiple nodes to the cache", function()
			local cache = LRU.new(100)
			cache:put("key1", "value1", 10)
			cache:put("key2", "value2", 20)
			assert.equals(cache.cache["key1"].node.tokens, "value1")
			assert.equals(cache.cache["key2"].node.tokens, "value2")
			assert.equals(cache.cache["key1"].content, "value1")
			assert.equals(cache.cache["key2"].content, "value2")
			assert.equals(cache.cache["key1"].count_tokens, 10)
			assert.equals(cache.cache["key2"].count_tokens, 20)
			assert.equals(cache.head.tokens, "value2")
			assert.equals(cache.tail.tokens, "value1")
			assert.equals(cache.current_tokens, 30)
		end)

		it("updates the head and tail upon insert", function()
			local cache = LRU.new(100)
			cache:put("key1", "value1", 10)
			cache:put("key2", "value2", 20)
			cache:put("key3", "value3", 30)
			assert.equals(cache.head.tokens, "value3")
			assert.equals(cache.tail.tokens, "value1")
		end)

		it("evicts the least recently used item when reaching the token limit", function()
			local cache = LRU.new(30)
			cache:put("key1", "value1", 10)
			cache:put("key2", "value2", 20)

			cache:put("key3", "value3", 10)

			assert.equals(cache.cache["key1"], nil)
			assert.equals(cache.cache["key2"].node.tokens, "value2")
			assert.equals(cache.cache["key3"].node.tokens, "value3")
			assert.equals(cache.head.tokens, "value3")
			assert.equals(cache.tail.tokens, "value2")
			assert.equals(cache.current_tokens, 30)
		end)

		it("evicts multiple items when reaching the token limit", function()
			local cache = LRU.new(19)
			cache:put("key1", "value1", 10)
			cache:put("key2", "value2", 10)

			cache:put("key3", "value3", 10)

			assert.equals(cache.cache["key1"], nil)
			assert.equals(cache.cache["key2"], nil)
			assert.equals(cache.cache["key3"].node.tokens, "value3")
			assert.equals(cache.head.tokens, "value3")
			assert.equals(cache.tail.tokens, "value3")
			assert.equals(cache.current_tokens, 10)
		end)

		it("handles eviction when adding multiple items at once", function()
			local cache = LRU.new(30)
			cache:put("key1", "value1", 10)
			cache:put("key2", "value2", 10)
			cache:put("key3", "value3", 10)

			cache:put("key4", "value4", 10)

			assert.equals(cache.cache["key1"], nil)
			assert.equals(cache.cache["key2"].node.tokens, "value2")
			assert.equals(cache.cache["key3"].node.tokens, "value3")
			assert.equals(cache.cache["key4"].node.tokens, "value4")
			assert.equals(cache.head.tokens, "value4")
			assert.equals(cache.tail.tokens, "value2")
			assert.equals(cache.current_tokens, 30)
		end)
	end)

	describe("on get", function()
		it("returns node by key", function()
			local cache = LRU.new(100)
			cache:put("key1", "foo", 10)
			cache:put("key2", "bar", 10)

			cached_values = cache:get("key2")

			assert.equals(cached_values, "bar")
		end)

		it("moves gotten node to the head", function()
			local cache = LRU.new(1000)

			cache:put("key1", "show me the maneeey", 10)
			cache:put("key2", "UwU", 20)
			cache:put("key3", "wassup!", 970)

			assert.equals(cache.head.tokens, "wassup!")
			cached_values = cache:get("key1")
			assert.equals(cache.head.tokens, "show me the maneeey")
		end)
	end)
end)
